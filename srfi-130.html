<html>
  <head>
    <title>SRFI 130: String cursors</title>
    <link rel="stylesheet" href="http://srfi.schemers.org/srfi.css" type="text/css" />
  </head>

  <body>

<h1>Title</h1>

String cursors

<h1>Author</h1>

John Cowan

<h1>Status</h1>

<p>This SRFI is currently in <em>draft</em> status. Here is <a href="http://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+130+at+srfi+dotschemers+dot+org">srfi-130@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="http://srfi-email.schemers.org/srfi-130">archive</a>.</p>
<ul>
  <li>Received: 2015/12/2</li>
  <li>60-day deadline: 2016/2/1</li>
  <li>Draft #1 published: 2015/12/3</li>
  <li>Draft #2 published: 2015/12/13</li>
</ul>

<h1>Abstract</h1>

This SRFI describes a library for manipulating subsequences of strings specified by <i>cursors</i> rather than the traditional string indexes.  While indexes are exact integers ranging from 0 to the length of the string they refer to, cursors may or may not be exact integers; if they are, they aren't necessarily consecutive, as they may refer to byte positions rather than character positions in the string.

<h1>Issues</h1>

<ol><li><p>(resolved)
</p></li>
<li><p>(resolved)
</p></li></ol>

<h1>Rationale</h1>

<p>
When SRFI 13 was defined in 1999, it was intended to provide efficient string operations on both whole strings and substrings.  At that time, it was normal for strings to be sequences of 8-bit characters, or in a few cases, characters of other fixed lengths.  Consequently, many of the SRFI 13 procedures accept optional <em>start</em> and <em>end</em> arguments for each of the string arguments, indexing the beginning and the end of the substring(s) to be operated on.
</p>
<p>
Unfortunately for this design, Unicode has become much more widely used, and it is now fairly common for implementations to store strings internally as UTF-8 or UTF-16 code unit sequences, which means that indexing operations are potentially O(n) rather than O(1).  Using opaque cursors makes it possible to iterate much more efficiently through such strings compared to incrementing or decrementing indexes.  Furthermore, string mutation can be extremely expensive if the storage used for the string needs to be expanded, particularly if the implementation does not use an indirect pointer to it (as in Chicken), so this SRFI does not provide for it.
</p>
<p>Variable-arity procedures are often slow and may not interact well with optional type checking in Schemes that provide it.  Therefore, the procedures of this SRFI require <em>cursor</em>, <em>start</em> and <em>end</em> arguments rather than making them optional.  Note that this means optional arguments may appear before required ones: this can be readily handled using <code>case-lambda</code>.</p>
<p>
The operations provided here are entirely independent of the character repertoire supported by the implementation.  In particular, this means that the comparison and case conversion procedures of SRFI 13 are excluded.  There is also no provision for <a class="ext-link" href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-2.html#node_idx_54">R6RS normalization procedures</a> or for an <tt>string-&gt;integer</tt> procedure that was proposed for SRFI 13 but not included.  These may appear in future SRFIs.
</p>
<p>In addition, the SRFI 13 procedures that accept two strings (and therefore up to four indexes) have been omitted from this SRFI, as they are clunky to use and interpret.  Some procedures that accept an arbitrary number of strings in R7RS-small have analogues here that accept just one string and optional start and end cursors.
</p>
<p>
This SRFI, therefore, is intended to help move the practice of Scheme programming away from mutable strings, string indexes, and SRFI 13, while maintaining some degree of conceptual backward compatibility.  It does not require any particular run-time efficiencies from its procedures.
</p>


<h1>Specification</h1>

<p>
Cursors are pointers into strings, and are not necessarily disjoint from other Scheme types.  For example, they may be exact integers that are character-based indexes into strings.  Alternatively, in an implementation whose internal representation of strings is UTF-8, cursors may be indexes of individual bytes in the string.  It is also possible to implement cursors as objects of a disjoint type.  The cursor procedures of this SRFI are mostly taken from Chibi Scheme.
</p>
<p>It is an error to make any use of a cursor referring to a string after the string has been mutated by a procedure like <code>string-set!</code>, <code>string-copy!</code>, or <code>string-fill!</code>.</p>
<p>
Given a string of length <em>n</em>, there are <em>n</em>+2 possible cursors that refer to it: one for each character in the string, one for the position just before the first character (known as the "pre-start cursor"), and one for the position just after the last character (known as the "post-end cursor").  These additional positions are provided for backward and forward iteration respectively, and also because when creating a string from cursors the second cursor argument is exclusive. It is an error if a cursor argument is not one of the possible cursors for the string or string argument.
</p>
<p>Arguments named <i>start</i> and <i>end</i> default to the cursor for the first character in the string and the post-string cursor respectively. </p>
<p>
<p>
All predicates passed to procedures defined in this SRFI may be called in any order and any number of times, except as otherwise noted.  In SRFI 13, there is no such provision, and so character sets are inherently more efficient than predicates <a class="ext-link" href="http://srfi.schemers.org/srfi-13/mail-archive/msg00052.html">because testing them is fast and free of side effects</a>, though how fast character sets are if they support full Unicode is very implementation-dependent.  Though not required to do so by this SRFI, implementations may extend procedures that accept predicates to accept <a href="http://srfi.schemers.org/srfi-14/srfi-14.html">SRFI 14</a> character sets or single characters or both.
</p>
Note: Procedures with similar names and purposes to R7RS-small or <a class="ext-link" href="http://srfi.schemers.org/srfi-13/srfi-13.html">SRFI 13</a> procedures are marked [R7RS-small] and [SRFI 13] respectively.
</p>
<h2>Procedure index</h2>
<p><a href="#stringcursors">String cursors</a><code>: string-cursor-start, string-cursor-end, string-cursor-next, string-cursor-prev, string-cursor-forward, string-cursor-backward, string-cursor=?, string-cursor&lt;?, string-cursor>?, string-cursor&lt;=?, string-cursor>=?</code></p>
<p><a href="#selection">Selection</a>: <code>string-ref/cursor, string-take/cursor, string-drop/cursor, string-split-at/cursor</code></p>
<p><a href="#paddingtrimmingandcompressing">Padding, trimming, and compressing</a>: <code>string-pad/cursors, string-pad-right/cursors, string-trim/cursors, string-trim-right/cursors, string-trim-both/cursors</code></p>
<p><a href="#searching">Padding, trimming, and compressing</a>: <code>string-count/cursors, string-find/cursors, string-find-right/cursors, string-skip/cursors, string-skip-right/cursors, string-take-while/cursors, string-drop-while/cursors, string-span/cursors, string-break/cursors</code></p>
<p><a href="#thewholestring">The whole string</a>: <code>string-reverse/cursors, string-every/cursors, string-any/cursors</code></p>
<p><a href="#foldingandmapping">Folding and mapping</a>: <code>string-map/cursors, string-for-each/cursors, string-for-each-cursor, string-fold/cursors, string-fold/cursors</code></p>
<p><a href="#parsing">Parsing</a>: <code>string-split/cursors</code></p>
<p><a href="#filteringandpartioning">Filtering and partitioning</a>: <code>string-filter/cursors, string-remove/cursors, string-partition</code></p>
<p><a href="#copying and conversion">Copying and conversion</a>: <code>string-copy/cursors, substring/cursors, string->list/cursors, string->vector/cursors</code></p>


<p>
<tt>(string-cursor-start </tt><em>string</em><tt>)</tt>
</p>
<p>
Returns a cursor referring to the first character in <em>string</em>.
</p>
<p>
<tt>(string-cursor-end </tt><em>string</em><tt>)</tt>
</p>
<p>
Returns the post-end cursor of <em>string</em>.
</p>
<p>
<tt>(string-cursor-ref </tt><em>string cursor</em><tt>)</tt>
</p>
<p>
Returns the character referred to by <em>cursor</em>.  It is an error if <em>cursor</em> is the pre-start or post-end cursor of <em>string</em> or <em>string</em>.
</p>
<p>
<tt>(string-cursor-next </tt><em>string cursor</em><tt>)</tt>
</p>
<p>
Returns the cursor following <em>cursor</em>.    It is an error if <em>cursor</em> is the post-end cursor of <em>string</em>.
</p>
<p>
<tt>(string-cursor-prev </tt><em>string cursor</em><tt>)</tt>
</p>
<p>
Returns the cursor preceding <em>cursor</em>.  It is an error if <em>cursor</em> is the pre-start cursor of <em>string</em>.
</p>
<p>
<tt>(string-cursor-forward </tt><em>string cursor n</em><tt>)</tt>
</p>
<p>
<tt>(string-cursor-backward </tt><em>string cursor n</em><tt>)</tt>
</p>
<p>
Iterates <tt>string-cursor-next</tt> or <tt>string-cursor-prev</tt> <em>n</em> times.
</p>
<p>
<tt>(string-cursor=? </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
<tt>(string-cursor&lt;? </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
<tt>(string-cursor&gt;? </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
<tt>(string-cursor&lt;=? </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
<tt>(string-cursor&gt;=? </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
Compare <em>cursor<sub>1</sub></em> and <em>cursor<sub>2</sub></em>.
</p>
<p>
<tt>(string-cursor-&gt;index </tt><em>string cursor</em><tt>)</tt>
</p>
<p>
Return the character index into <em>string</em> corresponding to <em>cursor</em>.  If <em>cursor</em> is the pre-start cursor of <em>string</em>, -1 is returned.  If <em>cursor</em> is the post-end cursor of <em>string</em> or <em>string</em>, the length of <em>string</em> or <em>string</em> is returned.  It is an error if <em>cursor</em> does not correspond to a specific index.
</p>
<p>
<tt>(string-index-&gt;cursor </tt><em>string index</em><tt>)</tt>
</p>
<p>
Returns the cursor referring to <em>string</em> that corresponds to <em>index</em>.  If <em>index</em> is -1, returns the pre-start cursor of <em>string</em> or <em>string</em>.  If <em>index</em> is equal to the length of <em>string</em> or <em>string</em>, returns the post-end cursor of <em>string</em> or <em>string</em>.
</p>
<p>
<tt>(string-cursor-difference </tt><em>string cursor<sub>1</sub> cursor<sub>2</sub></em><tt>)</tt>
</p>
<p>
Return the difference in characters between <em>cursor<sub>2</sub></em> and <em>cursor<sub>1</sub></em>.  The arguments are in reverse order from the subtraction procedure so that they can be passed as start and end cursors respectively.
</p>
<h2 id="Selection">Selection</h2>
<p>
<tt>(string-ref/cursor </tt><em>string cursor</em><tt>)</tt> [R7RS-small]
</p>
<p>
Returns the character of <em>string</em> referred to by <i>cursor</i>.  It is an error if <i>cursor</i> is the pre-start or post-end cursor of <i>string</i>.
</p>
<p>
<tt>(string-take/cursor </tt><em>string cursor</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a string which contains the characters of <em>string</em> up to but not including <i>cursor</i>.  It is an error if <i>cursor</i> is the pre-start cursor of <i>string</i>.
</p>
<p>
<tt>(string-drop/cursor </tt><em>string cursor</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a string which contains the characters of <em>string</em> starting with and including <i>cursor</i>.  It is an error if <i>cursor</i> is the post-end cursor of <i>string</i>.
</p>
<p>
Returns a string which contains all but the last <em>n</em> characters of <em>string</em>.
</p>
<p>
<tt>(string-split-at/cursor </tt><em>string cursor</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns two values, a string containing the characters of <em>string</em> to but not including <i>cursor</i>, and another string containing the the characters of <em>string</em> starting with and including <i>cursor</i>.  It is an error if <i>cursor</i> is the pre-start or post-end cursor of <i>string</i>.
</p>
<h2 id="Paddingtrimmingandcompressing">Padding, trimming, and compressing</h2>
<p>
<tt>(string-pad/cursors </tt><em>string len</em> [ <em>char</em> ] <em>start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
<tt>(string-pad-right/cursors </tt><em>string len</em> [ <em>char</em> ] <em>start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a string of length <em>len</em> consisting of the substring of <em>string</em> from <i>start</i> (inclusive) to <i>end</i> (inclusive), padded on the left/right by as many occurrences of the character <em>char</em> as needed.  If <em>string</em> has more than <em>len</em> characters, it is truncated on the left/right to length <em>len</em>.  If <em>char</em> is omitted, <tt>#\space</tt> is used.
</p>
<p>
<tt>(string-trim/cursors </tt><em>string</em> [ <em>pred</em> ] <em>start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
<tt>(string-trim-right/cursors </tt><em>string</em> [ <em>pred</em> ] <em>start end</em><tt>)</tt> [SRFI 13]
</p> 
<p>
<tt>(string-trim-both/cursors </tt><em>string</em> [ <em>pred</em> ] <em>start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Trim the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) by skipping over all characters on the left / on the right / on both sides that satisfy <em>pred</em> and returning the resulting string.  <em>Pred</em> defaults to <tt>(lambda (x) (eqv? x #\space))</tt>.
</p>
<p>
<tt>(string-compress/cursors </tt><em>string</em> [ <em>char</em> ] <em>start end</em><tt>)</tt>
</p>
<p>
Return a string which differs from the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) in that every sequence of consecutive occurrences of <em>char</em> has been replaced by a single <em>char</em>.  If <em>char</em> is omitted, <tt>#\space</tt> is used.
</p>
<h2 id="Searching">Searching</h2>
<p>
<tt>(string-count/cursors </tt><em>pred string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns the number of characters in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) which satisfy <em>pred</em> as an exact integer.
</p>
<p>
<tt>(string-find/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Returns a cursor referring to the first character in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) that satisfies <em>pred</em>, or the post-end cursor of <em>string</em> if there is none.
</p>
<p>
<tt>(string-find-right/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Returns a cursor referring to the first character in the substring of <em>string</em> from <em>end</em> (exclusive) to <em>start</em> (inclusive) that satisfies <em>pred</em>, processing it in reverse order, or the pre-start cursor of <em>string</em> if there is none.
</p>
<p>
Compatibility note:  These procedures are analogous to SRFI 13's <tt>string-index</tt> procedures, but return cursors rather than indexes or <tt>#f</tt> on failure.
</p>
<p>
<tt>(string-skip/cursors </tt><em>pred string</em><tt>)</tt> [SRFI 13]
</p>
<p>
<tt>(string-skip-right/cursors </tt><em>pred string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a cursor pointing to the first/last character in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) that does not satisfy <em>pred</em>, or the cursor after <i>end</i> / before <i>start</i> if there is none.
</p>
<p>
<tt>(string-take-while/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Returns the longest initial prefix of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) whose characters all satisfy <em>pred</em>. 
</p>
<p>
<tt>(string-drop-while/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Drops the longest initial prefix of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) whose characters all satisfy <em>pred</em>, and returns the rest of <em>string</em>. 
</p>
<p>
<tt>(string-span/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
<tt>(string-break/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
The <tt>string-span/cursors</tt> procedure splits the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive), returning two values: the longest initial prefix whose characters all satisfy <em>pred</em>, and the remainder of <em>string</em>.  The <tt>string-break/cursors</tt> procedure inverts the sense of the predicate: the remainder commences with the first character of <em>string</em> that satisfies <em>pred</em>.  In other words: <tt>string-span/cursors</tt> finds the intial string of characters satisfying <em>pred</em>, and <tt>string-break/cursors</tt> breaks <em>string</em> at the first character satisfying <em>pred</em>.
</p>
<h2 id="Thewholestring">The whole string</h2>
<p>
Returns the number of characters in <em>string</em>.
</p>
<p>
<tt>(string-reverse/cursors </tt><em>string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a string containing the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) in reverse order.
</p>
<p>
<tt>(string-every/cursors </tt><em>pred string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
If <em>pred</em> returns true for every character in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive), then returns what the last call to <em>pred</em> returns, or <tt>#t</tt> if <em>pred</em> is never called.  Returns <tt>#f</tt> otherwise.
</p>
<p>
<tt>(string-any/cursors </tt><em>pred string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns <tt>#f</tt> if <em>pred</em> returns false for each character in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive), and <tt>#t</tt> otherwise.
</p>
<h2 id="Foldingandmapping">Folding and mapping</h2>
<p>
<tt>(string-map/cursors </tt><em>proc string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Applies <em>proc</em> element-wise to the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) and returns a string of the results,
in order. The dynamic order in which <em>proc</em> is applied to the characters of the string is unspecified. If multiple returns occur from <tt>string-map/cursors</tt>, the values returned by earlier returns are not mutated.
</p>
<p>
<tt>(string-for-each/cursors </tt><em>proc string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
The arguments to <tt>string-for-each/cursors</tt> are like the arguments to <tt>string-map/cursors</tt>, but it calls <em>proc</em> for its
side effects rather than for its values. Unlike <tt>string-map</tt>, this procedure is guaranteed to call <em>proc</em> exactly once on each of the characters of the strings in order from the first character(s) to the last.  The value returned is unspecified.
</p>
<p>
<tt>(string-for-each-cursor </tt><em>proc string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Applies <em>proc</em> to each of the valid cursors (excluding the pre-start and post-end cursors) of <em>string</em>.  This procedure is guaranteed to call <em>proc</em> exactly once on each of the characters of the strings in order from the first character(s) to the last.  The value returned is unspecified.
</p>
<p>
<tt>(string-fold/cursors </tt><em>proc nil string</em><tt>)</tt> [SRFI 13]
</p>
<p>
<tt>(string-fold-right/cursors </tt><em>proc nil string</em><tt>)</tt> [SRFI 13]
</p>
<p>
Invokes <em>proc</em> on each character of the <em>strings</em> in forward/reverse order, passing the result of the previous invocation as an additional argument. For the first invocation, <em>nil</em> is used as the additional argument. Returns the result of the last invocation, or <em>nil</em> if there was no invocation.  It is an error if <em>proc</em> does not accept the same number of arguments as there are strings plus one.
</p>
<h2 id="Parsing">Parsing</h2>
<p>
<tt>(string-split/cursors </tt><em>string</em> [<em>separator</em> [ <em>limit ] ] start end</em><tt>)</tt>
</p>
<p>
Returns a list of the words contained in the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive).  If <em>separator</em> (which is also a string) is omitted, then the words are separated by one or more whitespace characters (those on which <tt>char-whitespace?</tt> returns <tt>#t</tt>). If <em>separator</em> is supplied, it specifies a string whose characters are to be used as the word separator. The returned list will then have one more item than the number of non-overlapping occurrences of the separator in the string.  If <em>separator</em> is an empty string, then the returned list contains a list of strings, each of which contains a single character. 
</p>
<p>
If <em>limit</em> is provided, at most that many splits occur, and the remainder of <em>string</em> is returned as the final element of the list (thus, the result will have at most <em>limit</em>+1 elements). If <em>limit</em> is not specified, then as many splits as possible are made.  It is an error if <em>limit</em> is not a positive exact integer.
</p>
<p>Compatibility note: This procedure replaces SRFI 13's <code>string-tokenize</code> with something modeled after the split operation of Perl, Python, Java, JavaScript, and other languages.</p>
<h2 id="Filteringandpartitioning">Filtering and partitioning</h2>
<p>
<tt>(string-filter/cursors </tt><em>pred string start end</em><tt>)</tt> [SRFI 13]
</p>
<p>
Returns a string containing the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) which satisfy <em>pred</em>.
</p>
<p>
<tt>(string-remove/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Returns a string containing the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) which do not satisfy <em>pred</em>.
</p>
<p>
Compatibility note:  The SRFI 13 version of this procedure is called <tt>string-delete</tt>, which is inconsistent with the conventions of SRFI 1 and other SRFIs.
</p>
<p>
<tt>(string-partition/cursors </tt><em>pred string start end</em><tt>)</tt>
</p>
<p>
Returns two values, a string containing the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) which satisfy <em>pred</em> and another string containing those which do not.
</p>
<h2 id="Copyingandconnversion">Copying and conversion</h2>
<p>
<tt>(string-copy/cursors </tt><em>span <em>start end</em></em><tt>)</tt> [R7RS-small]
</p>
<p>
<tt>(substring/cursors </tt><em>span start end</em><tt>)</tt> [R7RS-small]
</p>
<p>
These procedures are equivalent, and return a string which contains the characters in <em>string</em> between <em>start</em> (inclusive) and <em>end</em> (exclusive).
</p>
<p>
<tt>(string-&gt;list/cursors </tt><em>string start end</em><tt>)</tt> [R7RS-small]
</p>
<p>
<tt>(string-&gt;vector/cursors </tt><em>string start end</em><tt>)</tt> [R7RS-small]
</p>
<p>
Returns a newly allocated list/vector containing the characters of the substring of <em>string</em> from <em>start</em> (inclusive) to <em>end</em> (exclusive) in order.
</p>
<h1>Implementation</h1>

The sample implementation is (not yet) available in the SRFI's repository.  It will be written after a round of comments has been received.

<h1>Copyright</h1>
Copyright (C) John Cowan (2015).  All Rights Reserved. 

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.</p>

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr />
  <address>Editor: <a href="mailto:srfi-editors at srfi dot schemers dot org">Arthur A. Gleckler</a></address></body></html>
